{"ast":null,"code":"import { MapMode } from '@codemirror/state';\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\nclass RangeValue {\n  /**\n  Compare this value with another value. The default\n  implementation compares by identity.\n  */\n  eq(other) {\n    return this == other;\n  }\n  /**\n  Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.\n  */\n  range(from, to = from) {\n    return new Range(from, to, this);\n  }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\nclass Range {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The range's start position.\n  */\n  from,\n  /**\n  Its end position.\n  */\n  to,\n  /**\n  The value associated with this range.\n  */\n  value) {\n    this.from = from;\n    this.to = to;\n    this.value = value;\n  }\n}\nfunction cmpRange(a, b) {\n  return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n  constructor(from, to, value,\n  // Chunks are marked with the largest point that occurs\n  // in them (or -1 for no points), so that scans that are\n  // only interested in points (such as the\n  // heightmap-related logic) can skip range-only chunks.\n  maxPoint) {\n    this.from = from;\n    this.to = to;\n    this.value = value;\n    this.maxPoint = maxPoint;\n  }\n  get length() {\n    return this.to[this.to.length - 1];\n  }\n  // Find the index of the given position and side. Use the ranges'\n  // `from` pos when `end == false`, `to` when `end == true`.\n  findIndex(pos, side, end, startAt = 0) {\n    let arr = end ? this.to : this.from;\n    for (let lo = startAt, hi = arr.length;;) {\n      if (lo == hi) return lo;\n      let mid = lo + hi >> 1;\n      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n      if (mid == lo) return diff >= 0 ? lo : hi;\n      if (diff >= 0) hi = mid;else lo = mid + 1;\n    }\n  }\n  between(offset, from, to, f) {\n    for (let i = this.findIndex(from, -1000000000 /* Far */, true), e = this.findIndex(to, 1000000000 /* Far */, false, i); i < e; i++) if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;\n  }\n  map(offset, changes) {\n    let value = [],\n      from = [],\n      to = [],\n      newPos = -1,\n      maxPoint = -1;\n    for (let i = 0; i < this.value.length; i++) {\n      let val = this.value[i],\n        curFrom = this.from[i] + offset,\n        curTo = this.to[i] + offset,\n        newFrom,\n        newTo;\n      if (curFrom == curTo) {\n        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n        if (mapped == null) continue;\n        newFrom = newTo = mapped;\n        if (val.startSide != val.endSide) {\n          newTo = changes.mapPos(curFrom, val.endSide);\n          if (newTo < newFrom) continue;\n        }\n      } else {\n        newFrom = changes.mapPos(curFrom, val.startSide);\n        newTo = changes.mapPos(curTo, val.endSide);\n        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;\n      }\n      if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;\n      if (newPos < 0) newPos = newFrom;\n      if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);\n      value.push(val);\n      from.push(newFrom - newPos);\n      to.push(newTo - newPos);\n    }\n    return {\n      mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,\n      pos: newPos\n    };\n  }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#rangeset.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.update). This is an immutable data\nstructure.\n*/\nclass RangeSet {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  @internal\n  */\n  chunkPos,\n  /**\n  @internal\n  */\n  chunk,\n  /**\n  @internal\n  */\n  nextLayer = RangeSet.empty,\n  /**\n  @internal\n  */\n  maxPoint) {\n    this.chunkPos = chunkPos;\n    this.chunk = chunk;\n    this.nextLayer = nextLayer;\n    this.maxPoint = maxPoint;\n  }\n  /**\n  @internal\n  */\n  get length() {\n    let last = this.chunk.length - 1;\n    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n  }\n  /**\n  The number of ranges in the set.\n  */\n  get size() {\n    if (this.isEmpty) return 0;\n    let size = this.nextLayer.size;\n    for (let chunk of this.chunk) size += chunk.value.length;\n    return size;\n  }\n  /**\n  @internal\n  */\n  chunkEnd(index) {\n    return this.chunkPos[index] + this.chunk[index].length;\n  }\n  /**\n  Update the range set, optionally adding new ranges or filtering\n  out existing ones.\n  \n  (The extra type parameter is just there as a kludge to work\n  around TypeScript variance issues that prevented `RangeSet<X>`\n  from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n  `Y`.)\n  */\n  update(updateSpec) {\n    let {\n      add = [],\n      sort = false,\n      filterFrom = 0,\n      filterTo = this.length\n    } = updateSpec;\n    let filter = updateSpec.filter;\n    if (add.length == 0 && !filter) return this;\n    if (sort) add = add.slice().sort(cmpRange);\n    if (this.isEmpty) return add.length ? RangeSet.of(add) : this;\n    let cur = new LayerCursor(this, null, -1).goto(0),\n      i = 0,\n      spill = [];\n    let builder = new RangeSetBuilder();\n    while (cur.value || i < add.length) {\n      if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n        let range = add[i++];\n        if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);\n      } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n        cur.nextChunk();\n      } else {\n        if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n          if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(new Range(cur.from, cur.to, cur.value));\n        }\n        cur.next();\n      }\n    }\n    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({\n      add: spill,\n      filter,\n      filterFrom,\n      filterTo\n    }));\n  }\n  /**\n  Map this range set through a set of changes, return the new set.\n  */\n  map(changes) {\n    if (changes.empty || this.isEmpty) return this;\n    let chunks = [],\n      chunkPos = [],\n      maxPoint = -1;\n    for (let i = 0; i < this.chunk.length; i++) {\n      let start = this.chunkPos[i],\n        chunk = this.chunk[i];\n      let touch = changes.touchesRange(start, start + chunk.length);\n      if (touch === false) {\n        maxPoint = Math.max(maxPoint, chunk.maxPoint);\n        chunks.push(chunk);\n        chunkPos.push(changes.mapPos(start));\n      } else if (touch === true) {\n        let {\n          mapped,\n          pos\n        } = chunk.map(start, changes);\n        if (mapped) {\n          maxPoint = Math.max(maxPoint, mapped.maxPoint);\n          chunks.push(mapped);\n          chunkPos.push(pos);\n        }\n      }\n    }\n    let next = this.nextLayer.map(changes);\n    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n  }\n  /**\n  Iterate over the ranges that touch the region `from` to `to`,\n  calling `f` for each. There is no guarantee that the ranges will\n  be reported in any specific order. When the callback returns\n  `false`, iteration stops.\n  */\n  between(from, to, f) {\n    if (this.isEmpty) return;\n    for (let i = 0; i < this.chunk.length; i++) {\n      let start = this.chunkPos[i],\n        chunk = this.chunk[i];\n      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;\n    }\n    this.nextLayer.between(from, to, f);\n  }\n  /**\n  Iterate over the ranges in this set, in order, including all\n  ranges that end at or after `from`.\n  */\n  iter(from = 0) {\n    return HeapCursor.from([this]).goto(from);\n  }\n  /**\n  @internal\n  */\n  get isEmpty() {\n    return this.nextLayer == this;\n  }\n  /**\n  Iterate over the ranges in a collection of sets, in order,\n  starting from `from`.\n  */\n  static iter(sets, from = 0) {\n    return HeapCursor.from(sets).goto(from);\n  }\n  /**\n  Iterate over two groups of sets, calling methods on `comparator`\n  to notify it of possible differences.\n  */\n  static compare(oldSets, newSets,\n  /**\n  This indicates how the underlying data changed between these\n  ranges, and is needed to synchronize the iteration. `from` and\n  `to` are coordinates in the _new_ space, after these changes.\n  */\n  textDiff, comparator,\n  /**\n  Can be used to ignore all non-point ranges, and points below\n  the given size. When -1, all ranges are compared.\n  */\n  minPointSize = -1) {\n    let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n    let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n    let sharedChunks = findSharedChunks(a, b, textDiff);\n    let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n    let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n    if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);\n  }\n  /**\n  Compare the contents of two groups of range sets, returning true\n  if they are equivalent in the given range.\n  */\n  static eq(oldSets, newSets, from = 0, to) {\n    if (to == null) to = 1000000000 /* Far */;\n    let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);\n    let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);\n    if (a.length != b.length) return false;\n    if (!a.length) return true;\n    let sharedChunks = findSharedChunks(a, b);\n    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from),\n      sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n    for (;;) {\n      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;\n      if (sideA.to > to) return true;\n      sideA.next();\n      sideB.next();\n    }\n  }\n  /**\n  Iterate over a group of range sets at the same time, notifying\n  the iterator about the ranges covering every given piece of\n  content. Returns the open count (see\n  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end\n  of the iteration.\n  */\n  static spans(sets, from, to, iterator,\n  /**\n  When given and greater than -1, only points of at least this\n  size are taken into account.\n  */\n  minPointSize = -1) {\n    var _a;\n    let cursor = new SpanCursor(sets, null, minPointSize, (_a = iterator.filterPoint) === null || _a === void 0 ? void 0 : _a.bind(iterator)).goto(from),\n      pos = from;\n    let open = cursor.openStart;\n    for (;;) {\n      let curTo = Math.min(cursor.to, to);\n      if (cursor.point) {\n        iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n        open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n      } else if (curTo > pos) {\n        iterator.span(pos, curTo, cursor.active, open);\n        open = cursor.openEnd(curTo);\n      }\n      if (cursor.to > to) break;\n      pos = cursor.to;\n      cursor.next();\n    }\n    return open;\n  }\n  /**\n  Create a range set for the given range or array of ranges. By\n  default, this expects the ranges to be _sorted_ (by start\n  position and, if two start at the same position,\n  `value.startSide`). You can pass `true` as second argument to\n  cause the method to sort them.\n  */\n  static of(ranges, sort = false) {\n    let build = new RangeSetBuilder();\n    for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges) build.add(range.from, range.to, range.value);\n    return build.finish();\n  }\n}\n/**\nThe empty set of ranges.\n*/\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n  if (ranges.length > 1) for (let prev = ranges[0], i = 1; i < ranges.length; i++) {\n    let cur = ranges[i];\n    if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange);\n    prev = cur;\n  }\n  return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range) objects.\n*/\nclass RangeSetBuilder {\n  /**\n  Create an empty builder.\n  */\n  constructor() {\n    this.chunks = [];\n    this.chunkPos = [];\n    this.chunkStart = -1;\n    this.last = null;\n    this.lastFrom = -1000000000 /* Far */;\n    this.lastTo = -1000000000 /* Far */;\n    this.from = [];\n    this.to = [];\n    this.value = [];\n    this.maxPoint = -1;\n    this.setMaxPoint = -1;\n    this.nextLayer = null;\n  }\n  finishChunk(newArrays) {\n    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n    this.chunkPos.push(this.chunkStart);\n    this.chunkStart = -1;\n    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n    this.maxPoint = -1;\n    if (newArrays) {\n      this.from = [];\n      this.to = [];\n      this.value = [];\n    }\n  }\n  /**\n  Add a range. Ranges should be added in sorted (by `from` and\n  `value.startSide`) order.\n  */\n  add(from, to, value) {\n    if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);\n  }\n  /**\n  @internal\n  */\n  addInner(from, to, value) {\n    let diff = from - this.lastTo || value.startSide - this.last.endSide;\n    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n    if (diff < 0) return false;\n    if (this.from.length == 250 /* ChunkSize */) this.finishChunk(true);\n    if (this.chunkStart < 0) this.chunkStart = from;\n    this.from.push(from - this.chunkStart);\n    this.to.push(to - this.chunkStart);\n    this.last = value;\n    this.lastFrom = from;\n    this.lastTo = to;\n    this.value.push(value);\n    if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);\n    return true;\n  }\n  /**\n  @internal\n  */\n  addChunk(from, chunk) {\n    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;\n    if (this.from.length) this.finishChunk(true);\n    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n    this.chunks.push(chunk);\n    this.chunkPos.push(from);\n    let last = chunk.value.length - 1;\n    this.last = chunk.value[last];\n    this.lastFrom = chunk.from[last] + from;\n    this.lastTo = chunk.to[last] + from;\n    return true;\n  }\n  /**\n  Finish the range set. Returns the new set. The builder can't be\n  used anymore after this has been called.\n  */\n  finish() {\n    return this.finishInner(RangeSet.empty);\n  }\n  /**\n  @internal\n  */\n  finishInner(next) {\n    if (this.from.length) this.finishChunk(false);\n    if (this.chunks.length == 0) return next;\n    let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n    this.from = null; // Make sure further `add` calls produce errors\n    return result;\n  }\n}\nfunction findSharedChunks(a, b, textDiff) {\n  let inA = new Map();\n  for (let set of a) for (let i = 0; i < set.chunk.length; i++) if (set.chunk[i].maxPoint <= 0) inA.set(set.chunk[i], set.chunkPos[i]);\n  let shared = new Set();\n  for (let set of b) for (let i = 0; i < set.chunk.length; i++) {\n    let known = inA.get(set.chunk[i]);\n    if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length))) shared.add(set.chunk[i]);\n  }\n  return shared;\n}\nclass LayerCursor {\n  constructor(layer, skip, minPoint, rank = 0) {\n    this.layer = layer;\n    this.skip = skip;\n    this.minPoint = minPoint;\n    this.rank = rank;\n  }\n  get startSide() {\n    return this.value ? this.value.startSide : 0;\n  }\n  get endSide() {\n    return this.value ? this.value.endSide : 0;\n  }\n  goto(pos, side = -1000000000 /* Far */) {\n    this.chunkIndex = this.rangeIndex = 0;\n    this.gotoInner(pos, side, false);\n    return this;\n  }\n  gotoInner(pos, side, forward) {\n    while (this.chunkIndex < this.layer.chunk.length) {\n      let next = this.layer.chunk[this.chunkIndex];\n      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;\n      this.chunkIndex++;\n      forward = false;\n    }\n    if (this.chunkIndex < this.layer.chunk.length) {\n      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n      if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);\n    }\n    this.next();\n  }\n  forward(pos, side) {\n    if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);\n  }\n  next() {\n    for (;;) {\n      if (this.chunkIndex == this.layer.chunk.length) {\n        this.from = this.to = 1000000000 /* Far */;\n        this.value = null;\n        break;\n      } else {\n        let chunkPos = this.layer.chunkPos[this.chunkIndex],\n          chunk = this.layer.chunk[this.chunkIndex];\n        let from = chunkPos + chunk.from[this.rangeIndex];\n        this.from = from;\n        this.to = chunkPos + chunk.to[this.rangeIndex];\n        this.value = chunk.value[this.rangeIndex];\n        this.setRangeIndex(this.rangeIndex + 1);\n        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;\n      }\n    }\n  }\n  setRangeIndex(index) {\n    if (index == this.layer.chunk[this.chunkIndex].value.length) {\n      this.chunkIndex++;\n      if (this.skip) {\n        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex])) this.chunkIndex++;\n      }\n      this.rangeIndex = 0;\n    } else {\n      this.rangeIndex = index;\n    }\n  }\n  nextChunk() {\n    this.chunkIndex++;\n    this.rangeIndex = 0;\n    this.next();\n  }\n  compare(other) {\n    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;\n  }\n}\nclass HeapCursor {\n  constructor(heap) {\n    this.heap = heap;\n  }\n  static from(sets, skip = null, minPoint = -1) {\n    let heap = [];\n    for (let i = 0; i < sets.length; i++) {\n      for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {\n        if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));\n      }\n    }\n    return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n  }\n  get startSide() {\n    return this.value ? this.value.startSide : 0;\n  }\n  goto(pos, side = -1000000000 /* Far */) {\n    for (let cur of this.heap) cur.goto(pos, side);\n    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);\n    this.next();\n    return this;\n  }\n  forward(pos, side) {\n    for (let cur of this.heap) cur.forward(pos, side);\n    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);\n    if ((this.to - pos || this.value.endSide - side) < 0) this.next();\n  }\n  next() {\n    if (this.heap.length == 0) {\n      this.from = this.to = 1000000000 /* Far */;\n      this.value = null;\n      this.rank = -1;\n    } else {\n      let top = this.heap[0];\n      this.from = top.from;\n      this.to = top.to;\n      this.value = top.value;\n      this.rank = top.rank;\n      if (top.value) top.next();\n      heapBubble(this.heap, 0);\n    }\n  }\n}\nfunction heapBubble(heap, index) {\n  for (let cur = heap[index];;) {\n    let childIndex = (index << 1) + 1;\n    if (childIndex >= heap.length) break;\n    let child = heap[childIndex];\n    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n      child = heap[childIndex + 1];\n      childIndex++;\n    }\n    if (cur.compare(child) < 0) break;\n    heap[childIndex] = cur;\n    heap[index] = child;\n    index = childIndex;\n  }\n}\nclass SpanCursor {\n  constructor(sets, skip, minPoint, filterPoint = () => true) {\n    this.minPoint = minPoint;\n    this.filterPoint = filterPoint;\n    this.active = [];\n    this.activeTo = [];\n    this.activeRank = [];\n    this.minActive = -1;\n    // A currently active point range, if any\n    this.point = null;\n    this.pointFrom = 0;\n    this.pointRank = 0;\n    this.to = -1000000000 /* Far */;\n    this.endSide = 0;\n    this.openStart = -1;\n    this.cursor = HeapCursor.from(sets, skip, minPoint);\n  }\n  goto(pos, side = -1000000000 /* Far */) {\n    this.cursor.goto(pos, side);\n    this.active.length = this.activeTo.length = this.activeRank.length = 0;\n    this.minActive = -1;\n    this.to = pos;\n    this.endSide = side;\n    this.openStart = -1;\n    this.next();\n    return this;\n  }\n  forward(pos, side) {\n    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0) this.removeActive(this.minActive);\n    this.cursor.forward(pos, side);\n  }\n  removeActive(index) {\n    remove(this.active, index);\n    remove(this.activeTo, index);\n    remove(this.activeRank, index);\n    this.minActive = findMinIndex(this.active, this.activeTo);\n  }\n  addActive(trackOpen) {\n    let i = 0,\n      {\n        value,\n        to,\n        rank\n      } = this.cursor;\n    while (i < this.activeRank.length && this.activeRank[i] <= rank) i++;\n    insert(this.active, i, value);\n    insert(this.activeTo, i, to);\n    insert(this.activeRank, i, rank);\n    if (trackOpen) insert(trackOpen, i, this.cursor.from);\n    this.minActive = findMinIndex(this.active, this.activeTo);\n  }\n  // After calling this, if `this.point` != null, the next range is a\n  // point. Otherwise, it's a regular range, covered by `this.active`.\n  next() {\n    let from = this.to,\n      wasPoint = this.point;\n    this.point = null;\n    let trackOpen = this.openStart < 0 ? [] : null,\n      trackExtra = 0;\n    for (;;) {\n      let a = this.minActive;\n      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n        if (this.activeTo[a] > from) {\n          this.to = this.activeTo[a];\n          this.endSide = this.active[a].endSide;\n          break;\n        }\n        this.removeActive(a);\n        if (trackOpen) remove(trackOpen, a);\n      } else if (!this.cursor.value) {\n        this.to = this.endSide = 1000000000 /* Far */;\n        break;\n      } else if (this.cursor.from > from) {\n        this.to = this.cursor.from;\n        this.endSide = this.cursor.startSide;\n        break;\n      } else {\n        let nextVal = this.cursor.value;\n        if (!nextVal.point) {\n          // Opening a range\n          this.addActive(trackOpen);\n          this.cursor.next();\n        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n          // Ignore any non-empty points that end precisely at the end of the prev point\n          this.cursor.next();\n        } else if (!this.filterPoint(this.cursor.from, this.cursor.to, this.cursor.value, this.cursor.rank)) {\n          this.cursor.next();\n        } else {\n          // New point\n          this.point = nextVal;\n          this.pointFrom = this.cursor.from;\n          this.pointRank = this.cursor.rank;\n          this.to = this.cursor.to;\n          this.endSide = nextVal.endSide;\n          if (this.cursor.from < from) trackExtra = 1;\n          this.cursor.next();\n          this.forward(this.to, this.endSide);\n          break;\n        }\n      }\n    }\n    if (trackOpen) {\n      let openStart = 0;\n      while (openStart < trackOpen.length && trackOpen[openStart] < from) openStart++;\n      this.openStart = openStart + trackExtra;\n    }\n  }\n  activeForPoint(to) {\n    if (!this.active.length) return this.active;\n    let active = [];\n    for (let i = this.active.length - 1; i >= 0; i--) {\n      if (this.activeRank[i] < this.pointRank) break;\n      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide) active.push(this.active[i]);\n    }\n    return active.reverse();\n  }\n  openEnd(to) {\n    let open = 0;\n    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--) open++;\n    return open;\n  }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n  a.goto(startA);\n  b.goto(startB);\n  let endB = startB + length;\n  let pos = startB,\n    dPos = startB - startA;\n  for (;;) {\n    let diff = a.to + dPos - b.to || a.endSide - b.endSide;\n    let end = diff < 0 ? a.to + dPos : b.to,\n      clipEnd = Math.min(end, endB);\n    if (a.point || b.point) {\n      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);\n    } else {\n      if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);\n    }\n    if (end > endB) break;\n    pos = end;\n    if (diff <= 0) a.next();\n    if (diff >= 0) b.next();\n  }\n}\nfunction sameValues(a, b) {\n  if (a.length != b.length) return false;\n  for (let i = 0; i < a.length; i++) if (a[i] != b[i] && !a[i].eq(b[i])) return false;\n  return true;\n}\nfunction remove(array, index) {\n  for (let i = index, e = array.length - 1; i < e; i++) array[i] = array[i + 1];\n  array.pop();\n}\nfunction insert(array, index, value) {\n  for (let i = array.length - 1; i >= index; i--) array[i + 1] = array[i];\n  array[index] = value;\n}\nfunction findMinIndex(value, array) {\n  let found = -1,\n    foundPos = 1000000000 /* Far */;\n  for (let i = 0; i < array.length; i++) if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n    found = i;\n    foundPos = array[i];\n  }\n  return found;\n}\nexport { Range, RangeSet, RangeSetBuilder, RangeValue };","map":{"version":3,"names":["MapMode","RangeValue","eq","other","range","from","to","Range","prototype","startSide","endSide","point","mapMode","TrackDel","constructor","value","cmpRange","a","b","Chunk","maxPoint","length","findIndex","pos","side","end","startAt","arr","lo","hi","mid","diff","between","offset","f","i","e","map","changes","newPos","val","curFrom","curTo","newFrom","newTo","mapped","mapPos","Math","max","push","RangeSet","chunkPos","chunk","nextLayer","empty","last","chunkEnd","size","isEmpty","index","update","updateSpec","add","sort","filterFrom","filterTo","filter","slice","of","cur","LayerCursor","goto","spill","builder","RangeSetBuilder","addInner","rangeIndex","chunkIndex","addChunk","nextChunk","next","finishInner","chunks","start","touch","touchesRange","iter","HeapCursor","sets","compare","oldSets","newSets","textDiff","comparator","minPointSize","set","sharedChunks","findSharedChunks","sideA","SpanCursor","sideB","iterGaps","fromA","fromB","indexOf","sameValues","active","spans","iterator","_a","cursor","filterPoint","bind","open","openStart","min","activeForPoint","openEnd","span","ranges","build","lazySort","finish","prev","chunkStart","lastFrom","lastTo","setMaxPoint","finishChunk","newArrays","Error","result","inA","Map","shared","Set","known","get","layer","skip","minPoint","rank","gotoInner","forward","has","setRangeIndex","heap","heapBubble","top","childIndex","child","activeTo","activeRank","minActive","pointFrom","pointRank","removeActive","remove","findMinIndex","addActive","trackOpen","insert","wasPoint","trackExtra","nextVal","reverse","startA","startB","endB","dPos","clipEnd","comparePoint","compareRange","array","pop","found","foundPos"],"sources":["/Users/amansingh/Desktop/CodeWithMe/node_modules/@codemirror/rangeset/dist/index.js"],"sourcesContent":["import { MapMode } from '@codemirror/state';\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\nclass RangeValue {\n    /**\n    Compare this value with another value. The default\n    implementation compares by identity.\n    */\n    eq(other) { return this == other; }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.\n    */\n    range(from, to = from) { return new Range(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\nclass Range {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The range's start position.\n    */\n    from, \n    /**\n    Its end position.\n    */\n    to, \n    /**\n    The value associated with this range.\n    */\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // Find the index of the given position and side. Use the ranges'\n    // `from` pos when `end == false`, `to` when `end == true`.\n    findIndex(pos, side, end, startAt = 0) {\n        let arr = end ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1000000000 /* Far */, true), e = this.findIndex(to, 1000000000 /* Far */, false, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null)\n                    continue;\n                newFrom = newTo = mapped;\n                if (val.startSide != val.endSide) {\n                    newTo = changes.mapPos(curFrom, val.endSide);\n                    if (newTo < newFrom)\n                        continue;\n                }\n            }\n            else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)\n                    continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#rangeset.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.update). This is an immutable data\nstructure.\n*/\nclass RangeSet {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    chunkPos, \n    /**\n    @internal\n    */\n    chunk, \n    /**\n    @internal\n    */\n    nextLayer = RangeSet.empty, \n    /**\n    @internal\n    */\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */\n    get size() {\n        if (this.isEmpty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (The extra type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */\n    update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add = add.slice().sort(cmpRange);\n        if (this.isEmpty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(new Range(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */\n    map(changes) {\n        if (changes.empty || this.isEmpty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */\n    between(from, to, f) {\n        if (this.isEmpty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /**\n    @internal\n    */\n    get isEmpty() { return this.nextLayer == this; }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */\n    static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */\n    static compare(oldSets, newSets, \n    /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration. `from` and\n    `to` are coordinates in the _new_ space, after these changes.\n    */\n    textDiff, comparator, \n    /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */\n    minPointSize = -1) {\n        let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b, textDiff);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0)\n            compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Compare the contents of two groups of range sets, returning true\n    if they are equivalent in the given range.\n    */\n    static eq(oldSets, newSets, from = 0, to) {\n        if (to == null)\n            to = 1000000000 /* Far */;\n        let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);\n        let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);\n        if (a.length != b.length)\n            return false;\n        if (!a.length)\n            return true;\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n        for (;;) {\n            if (sideA.to != sideB.to ||\n                !sameValues(sideA.active, sideB.active) ||\n                sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))\n                return false;\n            if (sideA.to > to)\n                return true;\n            sideA.next();\n            sideB.next();\n        }\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end\n    of the iteration.\n    */\n    static spans(sets, from, to, iterator, \n    /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */\n    minPointSize = -1) {\n        var _a;\n        let cursor = new SpanCursor(sets, null, minPointSize, (_a = iterator.filterPoint) === null || _a === void 0 ? void 0 : _a.bind(iterator)).goto(from), pos = from;\n        let open = cursor.openStart;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n                open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n            }\n            else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, open);\n                open = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to)\n                break;\n            pos = cursor.to;\n            cursor.next();\n        }\n        return open;\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n}\n/**\nThe empty set of ranges.\n*/\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n    if (ranges.length > 1)\n        for (let prev = ranges[0], i = 1; i < ranges.length; i++) {\n            let cur = ranges[i];\n            if (cmpRange(prev, cur) > 0)\n                return ranges.slice().sort(cmpRange);\n            prev = cur;\n        }\n    return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range) objects.\n*/\nclass RangeSetBuilder {\n    /**\n    Create an empty builder.\n    */\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* Far */;\n        this.lastTo = -1000000000 /* Far */;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == 250 /* ChunkSize */)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */\n    finish() { return this.finishInner(RangeSet.empty); }\n    /**\n    @internal\n    */\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b, textDiff) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint <= 0)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++) {\n            let known = inA.get(set.chunk[i]);\n            if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &&\n                !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))\n                shared.add(set.chunk[i]);\n        }\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        if (this.chunkIndex < this.layer.chunk.length) {\n            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n            if (!forward || this.rangeIndex < rangeIndex)\n                this.setRangeIndex(rangeIndex);\n        }\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* Far */;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                this.setRangeIndex(this.rangeIndex + 1);\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    setRangeIndex(index) {\n        if (index == this.layer.chunk[this.chunkIndex].value.length) {\n            this.chunkIndex++;\n            if (this.skip) {\n                while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                    this.chunkIndex++;\n            }\n            this.rangeIndex = 0;\n        }\n        else {\n            this.rangeIndex = index;\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank ||\n            this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let i = 0; i < sets.length; i++) {\n            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* Far */;\n            this.value = null;\n            this.rank = -1;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint, filterPoint = () => true) {\n        this.minPoint = minPoint;\n        this.filterPoint = filterPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* Far */;\n        this.endSide = 0;\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        while (i < this.activeRank.length && this.activeRank[i] <= rank)\n            i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen)\n            insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen)\n                    remove(trackOpen, a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* Far */;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                }\n                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                }\n                else if (!this.filterPoint(this.cursor.from, this.cursor.to, this.cursor.value, this.cursor.rank)) {\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    if (this.cursor.from < from)\n                        trackExtra = 1;\n                    this.cursor.next();\n                    this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            let openStart = 0;\n            while (openStart < trackOpen.length && trackOpen[openStart] < from)\n                openStart++;\n            this.openStart = openStart + trackExtra;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length)\n            return this.active;\n        let active = [];\n        for (let i = this.active.length - 1; i >= 0; i--) {\n            if (this.activeRank[i] < this.pointRank)\n                break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)\n                active.push(this.active[i]);\n        }\n        return active.reverse();\n    }\n    openEnd(to) {\n        let open = 0;\n        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)\n            open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) &&\n                sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameValues(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i] && !a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction remove(array, index) {\n    for (let i = index, e = array.length - 1; i < e; i++)\n        array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for (let i = array.length - 1; i >= index; i--)\n        array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* Far */;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\nexport { Range, RangeSet, RangeSetBuilder, RangeValue };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}