{"ast":null,"code":"import { Facet, combineConfig, StateField } from '@codemirror/state';\nimport { syntaxTree } from '@codemirror/language';\nimport { EditorView, Decoration } from '@codemirror/view';\nimport { NodeProp } from '@lezer/common';\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \"&.cm-focused .cm-matchingBracket\": {\n    backgroundColor: \"#328c8252\"\n  },\n  \"&.cm-focused .cm-nonmatchingBracket\": {\n    backgroundColor: \"#bb555544\"\n  }\n});\nconst DefaultScanDist = 10000,\n  DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/Facet.define({\n  combine(configs) {\n    return combineConfig(configs, {\n      afterCursor: true,\n      brackets: DefaultBrackets,\n      maxScanDistance: DefaultScanDist\n    });\n  }\n});\nconst matchingMark = /*@__PURE__*/Decoration.mark({\n    class: \"cm-matchingBracket\"\n  }),\n  nonmatchingMark = /*@__PURE__*/Decoration.mark({\n    class: \"cm-nonmatchingBracket\"\n  });\nconst bracketMatchingState = /*@__PURE__*/StateField.define({\n  create() {\n    return Decoration.none;\n  },\n  update(deco, tr) {\n    if (!tr.docChanged && !tr.selection) return deco;\n    let decorations = [];\n    let config = tr.state.facet(bracketMatchingConfig);\n    for (let range of tr.state.selection.ranges) {\n      if (!range.empty) continue;\n      let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));\n      if (!match) continue;\n      let mark = match.matched ? matchingMark : nonmatchingMark;\n      decorations.push(mark.range(match.start.from, match.start.to));\n      if (match.end) decorations.push(mark.range(match.end.from, match.end.to));\n    }\n    return Decoration.set(decorations, true);\n  },\n  provide: f => EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [bracketMatchingState, baseTheme];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/\nfunction bracketMatching(config = {}) {\n  return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\nfunction matchingNodes(node, dir, brackets) {\n  let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);\n  if (byProp) return byProp;\n  if (node.name.length == 1) {\n    let index = brackets.indexOf(node.name);\n    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [brackets[index + dir]];\n  }\n  return null;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/\nfunction matchBrackets(state, pos, dir, config = {}) {\n  let maxScanDistance = config.maxScanDistance || DefaultScanDist,\n    brackets = config.brackets || DefaultBrackets;\n  let tree = syntaxTree(state),\n    node = tree.resolveInner(pos, dir);\n  for (let cur = node; cur; cur = cur.parent) {\n    let matches = matchingNodes(cur.type, dir, brackets);\n    if (matches && cur.from < cur.to) return matchMarkedBrackets(state, pos, dir, cur, matches, brackets);\n  }\n  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\n  let parent = token.parent,\n    firstToken = {\n      from: token.from,\n      to: token.to\n    };\n  let depth = 0,\n    cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;\n  if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {\n    if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n      if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n        return {\n          start: firstToken,\n          end: {\n            from: cursor.from,\n            to: cursor.to\n          },\n          matched: true\n        };\n      } else if (matchingNodes(cursor.type, dir, brackets)) {\n        depth++;\n      } else if (matchingNodes(cursor.type, -dir, brackets)) {\n        depth--;\n        if (depth == 0) return {\n          start: firstToken,\n          end: cursor.from == cursor.to ? undefined : {\n            from: cursor.from,\n            to: cursor.to\n          },\n          matched: false\n        };\n      }\n    }\n  } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n  return {\n    start: firstToken,\n    matched: false\n  };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n  let bracket = brackets.indexOf(startCh);\n  if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;\n  let startToken = {\n    from: dir < 0 ? pos - 1 : pos,\n    to: dir > 0 ? pos + 1 : pos\n  };\n  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0),\n    depth = 0;\n  for (let distance = 0; !iter.next().done && distance <= maxScanDistance;) {\n    let text = iter.value;\n    if (dir < 0) distance += text.length;\n    let basePos = pos + distance * dir;\n    for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n      let found = brackets.indexOf(text[pos]);\n      if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType) continue;\n      if (found % 2 == 0 == dir > 0) {\n        depth++;\n      } else if (depth == 1) {\n        // Closing\n        return {\n          start: startToken,\n          end: {\n            from: basePos + pos,\n            to: basePos + pos + 1\n          },\n          matched: found >> 1 == bracket >> 1\n        };\n      } else {\n        depth--;\n      }\n    }\n    if (dir > 0) distance += text.length;\n  }\n  return iter.done ? {\n    start: startToken,\n    matched: false\n  } : null;\n}\nexport { bracketMatching, matchBrackets };","map":{"version":3,"names":["Facet","combineConfig","StateField","syntaxTree","EditorView","Decoration","NodeProp","baseTheme","backgroundColor","DefaultScanDist","DefaultBrackets","bracketMatchingConfig","define","combine","configs","afterCursor","brackets","maxScanDistance","matchingMark","mark","class","nonmatchingMark","bracketMatchingState","create","none","update","deco","tr","docChanged","selection","decorations","config","state","facet","range","ranges","empty","match","matchBrackets","head","doc","length","matched","push","start","from","to","end","set","provide","f","bracketMatchingUnique","bracketMatching","of","matchingNodes","node","dir","byProp","prop","openedBy","closedBy","name","index","indexOf","pos","tree","resolveInner","cur","parent","matches","type","matchMarkedBrackets","matchPlainBrackets","_state","_pos","token","matching","firstToken","depth","cursor","childBefore","childAfter","undefined","prevSibling","nextSibling","tokenType","startCh","sliceDoc","bracket","startToken","iter","iterRange","distance","next","done","text","value","basePos","found","resolve"],"sources":["/Users/amansingh/Desktop/CodeWithMe/node_modules/@codemirror/matchbrackets/dist/index.js"],"sourcesContent":["import { Facet, combineConfig, StateField } from '@codemirror/state';\nimport { syntaxTree } from '@codemirror/language';\nimport { EditorView, Decoration } from '@codemirror/view';\nimport { NodeProp } from '@lezer/common';\n\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \"&.cm-focused .cm-matchingBracket\": { backgroundColor: \"#328c8252\" },\n    \"&.cm-focused .cm-nonmatchingBracket\": { backgroundColor: \"#bb555544\" }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist\n        });\n    }\n});\nconst matchingMark = /*@__PURE__*/Decoration.mark({ class: \"cm-matchingBracket\" }), nonmatchingMark = /*@__PURE__*/Decoration.mark({ class: \"cm-nonmatchingBracket\" });\nconst bracketMatchingState = /*@__PURE__*/StateField.define({\n    create() { return Decoration.none; },\n    update(deco, tr) {\n        if (!tr.docChanged && !tr.selection)\n            return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges) {\n            if (!range.empty)\n                continue;\n            let match = matchBrackets(tr.state, range.head, -1, config)\n                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))\n                || (config.afterCursor &&\n                    (matchBrackets(tr.state, range.head, 1, config) ||\n                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));\n            if (!match)\n                continue;\n            let mark = match.matched ? matchingMark : nonmatchingMark;\n            decorations.push(mark.range(match.start.from, match.start.to));\n            if (match.end)\n                decorations.push(mark.range(match.end.from, match.end.to));\n        }\n        return Decoration.set(decorations, true);\n    },\n    provide: f => EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/\nfunction bracketMatching(config = {}) {\n    return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);\n    if (byProp)\n        return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))\n            return [brackets[index + dir]];\n    }\n    return null;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/\nfunction matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);\n    for (let cur = node; cur; cur = cur.parent) {\n        let matches = matchingNodes(cur.type, dir, brackets);\n        if (matches && cur.from < cur.to)\n            return matchMarkedBrackets(state, pos, dir, cur, matches, brackets);\n    }\n    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\n    let parent = token.parent, firstToken = { from: token.from, to: token.to };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))\n        do {\n            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n                if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n                    return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };\n                }\n                else if (matchingNodes(cursor.type, dir, brackets)) {\n                    depth++;\n                }\n                else if (matchingNodes(cursor.type, -dir, brackets)) {\n                    depth--;\n                    if (depth == 0)\n                        return {\n                            start: firstToken,\n                            end: cursor.from == cursor.to ? undefined : { from: cursor.from, to: cursor.to },\n                            matched: false\n                        };\n                }\n            }\n        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return { start: firstToken, matched: false };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))\n        return null;\n    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {\n        let text = iter.value;\n        if (dir < 0)\n            distance += text.length;\n        let basePos = pos + distance * dir;\n        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType)\n                continue;\n            if ((found % 2 == 0) == (dir > 0)) {\n                depth++;\n            }\n            else if (depth == 1) { // Closing\n                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };\n            }\n            else {\n                depth--;\n            }\n        }\n        if (dir > 0)\n            distance += text.length;\n    }\n    return iter.done ? { start: startToken, matched: false } : null;\n}\n\nexport { bracketMatching, matchBrackets };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}